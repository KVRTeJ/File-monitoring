# File-monitoring

## Постановка задачи
 Написать программу с консольным интерфейсом, которая выполняет слежение за выбранными файлами.

Ограничимся  двумя характеристиками за изменениями которых выполняется слежение  :

> 1. Существование файла;
> 2. Размер файла.

Программа будет выводить на консоль уведомление о произошедших изменениях в файле.

Существует несколько ситуаций для наблюдаемого файла:

> 1. Файл существует , файл не  пустой - на экран выводится факт  существования файла и его  размер.
> 2. Файл существует, файл был изменен - на экран выводится факт существования файла, сообщение о том что файл был изменен и его размер.  
> 3. Файл не существует - на экран выводится информация о том что файл не существует.

При возникновении изменения состояния наблюдаемого файла ( возникновение события ), необходимо выводить на экран соответствующее сообщение.

В данной реализации используем механизм сигнально-слотового соединения для обеспечения обработки события изменения наблюдаемого файла.

## Предлагаемое решение.

Для решения данной задачи была использована сигнально-слотовая связь, между двумя основными сущностями проекта: 
 1. FileObserver, который испускает сигналы, при изменении состояния файла/файлов
 2. IFileLog(интерфейс), который имеет слоты - они и будут принимать сигналы. 

## Сигналы и слоты

*Сигналы в FileObserver*
```cpp
signals:
    void fileExist(const QString &path, qint64 size);
    void fileChanged(const QString &path, qint64 size);
    void fileNotExist(const QString &path);
```

*Слоты в IFileLog*
```cpp
public slots:
    virtual void fileExist(const QString &path, qint64 size) = 0;
    virtual void fileChanged(const QString &path, qint64 size) = 0;
    virtual void fileNotExist(const QString &path) = 0;
```

Сигнально-слотовая связь настраивается в классе FileObserver, в методе setLogger(IFileLog*). 
При этом заранее проверяется, не передан ли нулевой указатель IFileLog. В этом случае сигналы и слоты связываться не будут. 
```cpp
void FileObserver::setLogger(IFileLog *logger) {
    if(!logger) {
        m_logger = nullptr;
        return;
    }

    m_logger = logger;

    connect(this, SIGNAL(fileExist(QString,qint64)), m_logger, SLOT(fileExist(QString,qint64)));
    connect(this, SIGNAL(fileChanged(QString,qint64)), m_logger, SLOT(fileChanged(QString,qint64)));
    connect(this, SIGNAL(fileNotExist(QString)), m_logger, SLOT(fileNotExist(QString)));
}
```

## Консольный интерфейс

В задаче было условие написать программу с консольным интерфейсом, поэтому был создан порожденный класс от IFileLog - ConsoleFileLog, он и отвечает за логирование изменений файла/файлов в консоль.

*Пример реализации логирования в консоль*
```cpp
void ConsoleFileLog::fileExist(const QString &path, const qint64 size) {
    std::cout << "File " << path.toStdString() << " changed size to " << size << std::endl;
}
```

## Паттерны проектирования

Был реализован пораждающий паттерн проектирования Singleton(одиночка) для класса FileObserver, реализация данного паттерна находится во ветвлении от develop - в ветке addingSingleton. Одиночка использован для гарантии того, что у FileObserver будет только один экземпляр, который будет доступен *по ссылке* через static метод класса Instance(). В этом методе используется "ленивая" инициализация объекта типа FileObserver. 
```cpp
FileObserver& FileObserver::Instance() {
    static FileObserver observer;
    return observer;
}
```
Итак, у нас есть метод для полчения ссылки на экземпляр класса, теперь нужно запретить создание новых объектов, для этого конструктор(по умолчанию, с аргументом) и деструктор были вынесены в private. 
```cpp
private:
    FileObserver(IFileLog *logger = nullptr);
    ~FileObserver() override = default;
```

Также удалены способы копирования(конструктор копирования, оператор присваивания), это сделано через оператор delete, который запрещает любое копирование объектов типа FileObserver.

```cpp
 FileObserver(const FileObserver &other) = delete;
 FileObserver& operator = (const FileObserver &other) = delete;
```

## Тестирование

В рамках тестирования функциональности программы были проведены следующие проверки:

### 1. Мониторинг одного файла

Проверено базовое отслеживание состояния одиночного файла. FileObserver корректно определяет существование, изменение и отсутствие файла.

```cpp
FileObserver& observer = FileObserver::Instance();
observer.setLogger(new ConsoleFileLog());
observer.add("usr/temp/example.txt");

for(;;) {
    observer.check();   
}
```

### 2. Мониторинг нескольких файлов

Система успешно отслеживает несколько файлов одновременно. Сигналы о состоянии файлов генерируются независимо для каждого файла в списке мониторинга.

```cpp
FileObserver& observer = FileObserver::Instance();
observer.add("usr/temp/config.txt");
observer.add("usr/temp/data.log");
observer.add("usr/temp/settings.json");
```

### 3. Добавление одинаковых путей файлов

Подтверждено, что FileObserver защищен от добавления дубликатов путей. При попытке добавить уже отслеживаемый путь, метод `add()` вернет `false` и дубликат не добавится в список отслеживаемых файлов.

```cpp
FileObserver& observer = FileObserver::Instance();
observer.add("usr/temp/config.txt"); // Вернет true, файл успешно добавлен в отслеживаемые
observer.add("usr/temp/config.txt"); // Вернет false, дубликат не добавится
```

Все тесты подтвердили корректную работу основных функций программы в соответствии с ожидаемым поведением.

## Инструкция пользователя

### Базовая настройка

Настройка мониторинга файлов выполняется в несколько простых шагов:

1. Получите экземпляр FileObserver с помощью паттерна Singleton
2. Установите логгер для обработки событий
3. Добавьте файлы для мониторинга
4. Периодически вызывайте метод `check()` для проверки состояния файлов

```cpp
// Получение экземпляра FileObserver
FileObserver& observer = FileObserver::Instance();

// Создание и установка логгера
ConsoleFileLog logger;
observer.setLogger(&logger);

// Добавление файлов для мониторинга
observer.add("/path/to/your/file.txt");
observer.add("/path/to/another/file.log");

// Периодическая проверка файлов
// Можно использовать таймер или цикл
while (running) {
    observer.check();
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
}
```

### Интерпретация событий

При вызове метода `check()` FileObserver проверяет состояние всех отслеживаемых файлов и генерирует соответствующие события:

- **fileExist** — файл существует и не менялся с момента последней проверки
- **fileChanged** — файл был изменен с момента последней проверки
- **fileNotExist** — файл не существует

События обрабатываются логгером, который вы установете с помощью метода `setLogger()`. По умолчанию идет `ConsoleFileLog`, который выводит информацию о событиях в консоль.

### Подготовка тестовых файлов

Для тестирования библиотеки вы можете использовать следующие действия:

1. Создайте текстовый файл по указанному в вашем коде пути
2. Запустите приложение — вы увидите событие `fileExist`
3. Измените содержимое файла — будет сгенерировано событие `fileChanged`
4. Удалите файл — произойдет событие `fileNotExist`
5. Снова создайте файл — опять появится событие `fileExist`

### Настройка частоты проверки

В примере используется интервал проверки 100 мс, что обеспечивает быструю реакцию на изменения, но может создать дополнительную нагрузку на систему. Для реальных приложений рекомендуется использовать более длительный интервал, например:

```cpp
// Проверка каждую секунду
std::this_thread::sleep_for(std::chrono::seconds(1));

// или

// Проверка каждые 5 секунд для файлов, которые редко меняются
std::this_thread::sleep_for(std::chrono::seconds(5));
```

### Управление списком мониторинга

Можно динамически добавлять и удалять файлы из списка мониторинга:

```cpp
// Добавление нового файла
bool success = observer.add("/path/to/new/file.dat");
if (!success) {
    // Файл уже находится в списке мониторинга
}

// Удаление файла из мониторинга
bool removed = observer.remove("/path/to/old/file.log");
if (!removed) {
    // Файл не был найден в списке мониторинга
}
```

## UML

![Диаграмма без названия drawio-2-4](https://github.com/user-attachments/assets/8b2ac958-c208-46e7-8624-12c376dad121)

